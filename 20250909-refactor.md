# Antimoji Refactoring Plan
**Date:** September 9, 2025  
**Version:** 1.0  
**Status:** Draft  

## üìã Executive Summary

This document outlines a comprehensive refactoring plan for the Antimoji project to address critical architectural issues, eliminate antipatterns, and improve maintainability. The refactoring is structured in three stages over 16 weeks, targeting dependency injection, clean architecture, and performance optimization.

### Key Issues Identified
- Global state management antipatterns
- Panic-based error handling
- Tight coupling between layers
- Complex configuration management
- Testing architecture problems
- Concurrency inefficiencies

### Expected Outcomes
- 100% elimination of global state
- 30% memory usage reduction
- 50% CLI startup improvement
- 85%+ test coverage maintenance
- Clean architecture implementation
- Production-ready performance

---

## üîç Current State Analysis

### Critical Issues Found

#### 1. Global State Management Antipatterns
**Location:** `internal/observability/logging/global.go`, `internal/ui/output.go`, `internal/cli/root.go`
- Global logger singleton with mutex protection
- Global UI output singleton
- Package-level CLI flag variables
- Hidden dependencies throughout codebase

#### 2. Error Handling Problems
**Location:** `internal/types/result.go:37`
```go
// üö® ANTIPATTERN: Panic in library code
func (r Result[T]) Unwrap() T {
    if r.err != nil {
        panic(fmt.Sprintf("called Unwrap on an Err value: %v", r.err))
    }
    return r.value
}
```

#### 3. Architectural Coupling Issues
- CLI layer directly instantiates business logic
- Configuration scattered across layers
- Circular dependencies between packages
- No clear separation of concerns

#### 4. Configuration Management Problems
- Viper global state usage
- Complex profile merging logic
- Scattered validation
- Default value duplication

---

## üéØ Refactoring Strategy

### Three-Stage Approach

**Stage 1 (Weeks 1-6): Foundation**
- Eliminate global state
- Implement dependency injection
- Fix error handling antipatterns

**Stage 2 (Weeks 7-12): Architecture** 
- Implement clean architecture
- Create domain-driven design structure
- Overhaul configuration management

**Stage 3 (Weeks 13-16): Optimization**
- Performance improvements
- Advanced error handling
- Comprehensive monitoring

---

## üèóÔ∏è Stage 1: Foundation (Weeks 1-6)

### Task 1.1: Remove Global Logger Singleton
**Priority:** Critical | **Effort:** 1 week | **Assignee:** Senior Developer

#### Implementation Steps
1. Create Logger interface contract
2. Implement dependency injection for logger
3. Update application bootstrap
4. Remove global logger instance

#### Acceptance Criteria
- [ ] No global logger variables remain
- [ ] All functions accept logger via DI
- [ ] Zero global logging calls
- [ ] All tests pass with mock logger
- [ ] Performance maintained (¬±5%)

#### Validation Commands
```bash
grep -r "globalLogger" internal/ && exit 1 || echo "‚úÖ No global logger"
grep -r "logging\.(Info|Error)" internal/ | grep -v "_test.go" && exit 1 || echo "‚úÖ No global calls"
go test ./... -v
```

### Task 1.2: Remove Global UI Output Singleton  
**Priority:** Critical | **Effort:** 1 week | **Assignee:** Mid-level Developer

#### Implementation Steps
1. Create UserOutput interface
2. Inject UI output dependencies  
3. Update output configuration
4. Remove global UI instance

#### Acceptance Criteria
- [ ] No global UI output variables
- [ ] All output through injected interface
- [ ] Output formats work correctly
- [ ] Thread-safety maintained

#### Validation Commands
```bash
grep -r "globalUserOutput" internal/ && exit 1 || echo "‚úÖ No global UI"
./bin/antimoji scan --format=json . | jq . && echo "‚úÖ JSON works"
./bin/antimoji scan --format=table . | grep -q "‚îÇ" && echo "‚úÖ Table works"
```

### Task 1.3: Eliminate CLI Global Variables
**Priority:** High | **Effort:** 1 week | **Assignee:** Senior Developer

#### Implementation Steps
1. Create CLIContext structure
2. Refactor command constructors
3. Update Viper integration
4. Remove package-level variables

#### Acceptance Criteria
- [ ] No package-level variables in CLI
- [ ] All flags accessible through context
- [ ] Configuration file loading works
- [ ] Environment variables supported

### Task 1.4: Fix Result Type Panic Antipattern
**Priority:** Critical | **Effort:** 3 days | **Assignee:** Senior Developer

#### Implementation Steps
1. Add safe `Unwrap() (T, error)` method
2. Rename existing to `MustUnwrap()`
3. Update all callers to use safe version
4. Add comprehensive error context

#### Acceptance Criteria
- [ ] No panic calls in production code
- [ ] All Unwrap calls handle errors
- [ ] Error messages include context
- [ ] No regression in functionality

### Task 1.5: Create Application Dependency Container
**Priority:** High | **Effort:** 1 week | **Assignee:** Senior Developer

#### Implementation Steps
1. Design Dependencies struct
2. Create Application bootstrap
3. Update main entry point
4. Add lifecycle management

#### Acceptance Criteria
- [ ] All dependencies injected
- [ ] No circular dependencies
- [ ] Clean startup/shutdown
- [ ] All commands work with DI

---

## üèóÔ∏è Stage 2: Architecture (Weeks 7-12)

### Task 2.1: Implement Domain-Driven Design Structure
**Priority:** Critical | **Effort:** 2 weeks | **Assignee:** Senior Developer + Architect

#### New Directory Structure
```
internal/
‚îú‚îÄ‚îÄ domain/           # Business rules and entities
‚îÇ   ‚îú‚îÄ‚îÄ emoji/       # Emoji domain logic
‚îÇ   ‚îú‚îÄ‚îÄ file/        # File domain logic  
‚îÇ   ‚îî‚îÄ‚îÄ policy/      # Policy domain logic
‚îú‚îÄ‚îÄ application/     # Use cases and services
‚îÇ   ‚îú‚îÄ‚îÄ scan/        # Scan use case
‚îÇ   ‚îú‚îÄ‚îÄ clean/       # Clean use case
‚îÇ   ‚îî‚îÄ‚îÄ generate/    # Generate use case
‚îú‚îÄ‚îÄ infrastructure/ # External concerns
‚îÇ   ‚îú‚îÄ‚îÄ filesystem/
‚îÇ   ‚îú‚îÄ‚îÄ config/
‚îÇ   ‚îî‚îÄ‚îÄ concurrency/
‚îî‚îÄ‚îÄ interfaces/     # Adapters
    ‚îú‚îÄ‚îÄ cli/        # CLI adapter
    ‚îî‚îÄ‚îÄ output/     # Output adapter
```

#### Acceptance Criteria
- [ ] Domain objects contain business logic
- [ ] No infrastructure deps in domain
- [ ] Application layer orchestrates domain
- [ ] Repository pattern implemented
- [ ] Use cases testable in isolation

### Task 2.2: Implement Rich Domain Models
**Priority:** High | **Effort:** 1.5 weeks | **Assignee:** Senior Developer

#### Domain Model Examples
```go
// Value Objects
type Pattern struct {
    value    string
    category PatternCategory
}

func NewPattern(value string, category PatternCategory) (Pattern, error) {
    if value == "" {
        return Pattern{}, errors.New("pattern cannot be empty")
    }
    return Pattern{value: value, category: category}, nil
}

// Aggregate Root
type DetectionPolicy struct {
    allowedPatterns []Pattern
    strictMode      bool
}

func (dp DetectionPolicy) ShouldAllow(pattern Pattern) bool {
    // Business rules implementation
}
```

#### Acceptance Criteria
- [ ] Value objects are immutable
- [ ] Validation in domain constructors
- [ ] Business rules in domain objects
- [ ] No primitive obsession
- [ ] Aggregate boundaries defined

### Task 2.3: Create Configuration Management Service
**Priority:** High | **Effort:** 1 week | **Assignee:** Mid-level Developer

#### Implementation Approach
```go
// Immutable Configuration with Builder
type ConfigBuilder struct {
    profiles map[string]ProfileBuilder
}

func (cb *ConfigBuilder) AddProfile(name string, profile ProfileBuilder) *ConfigBuilder {
    cb.profiles[name] = profile
    return cb
}

func (cb *ConfigBuilder) Build() (Config, error) {
    // Validation and immutable config creation
}
```

#### Acceptance Criteria
- [ ] Configuration objects immutable
- [ ] Comprehensive validation
- [ ] Builder pattern implemented
- [ ] Environment variable support
- [ ] Profile inheritance works

### Task 2.4: Implement Repository Pattern
**Priority:** Medium | **Effort:** 1 week | **Assignee:** Mid-level Developer

#### Repository Interfaces
```go
type ConfigurationRepository interface {
    Load(path string) (Config, error)
    Save(path string, config Config) error
    Watch(path string) (<-chan Config, error)
}

type FileRepository interface {
    ReadFile(path string) ([]byte, error)
    WriteFileAtomic(path string, data []byte) error
    IsTextFile(path string) bool
}
```

#### Acceptance Criteria
- [ ] Repository interfaces in domain
- [ ] Implementations in infrastructure
- [ ] All file ops through repository
- [ ] Atomic operations prevent corruption
- [ ] In-memory implementations for tests

### Task 2.5: Create Use Case Layer
**Priority:** High | **Effort:** 1.5 weeks | **Assignee:** Senior Developer

#### Use Case Implementation
```go
type ScanUseCase struct {
    fileRepo   FileRepository
    detector   emoji.Detector
    policy     DetectionPolicy
    logger     Logger
}

func (uc *ScanUseCase) Execute(ctx context.Context, req ScanRequest) (ScanResult, error) {
    // Orchestrate domain objects
    // Handle cross-cutting concerns
    // Return rich result
}
```

#### Acceptance Criteria
- [ ] Single responsibility use cases
- [ ] Technology-agnostic business logic
- [ ] Progress reporting supported
- [ ] Cancellation implemented
- [ ] Easily testable

### Task 2.6: Implement Testing Infrastructure
**Priority:** High | **Effort:** 1 week | **Assignee:** All Developers

#### Testing Framework
```go
type TestDependencies struct {
    Logger     *MockLogger
    FileSystem *MockFileSystem
    UI         *MockUI
}

type IntegrationTestSuite struct {
    tempDir     string
    application *Application
    deps        TestDependencies
}
```

#### Acceptance Criteria
- [ ] All dependencies mockable
- [ ] Integration tests isolated
- [ ] Test data management automated
- [ ] Contract tests implemented
- [ ] Coverage maintained >85%

---

## ‚ö° Stage 3: Optimization (Weeks 13-16)

### Task 3.1: Optimize Concurrency Architecture
**Priority:** High | **Effort:** 1 week | **Assignee:** Senior Developer

#### Simplified Approach
```go
type WorkerPool struct {
    workers   int
    workQueue chan func() error
    results   chan error
    ctx       context.Context
    cancel    context.CancelFunc
}
```

#### Acceptance Criteria
- [ ] 50% reduction in worker pool complexity
- [ ] 30% memory usage reduction
- [ ] Proper goroutine cleanup
- [ ] Context cancellation works
- [ ] Performance maintained/improved

### Task 3.2: Implement Memory-Efficient Processing
**Priority:** Medium | **Effort:** 1 week | **Assignee:** Mid-level Developer

#### Streaming Detection
```go
type StreamingDetector struct {
    buffer   []byte
    position int
}

func (sd *StreamingDetector) ProcessChunk(chunk []byte) ([]EmojiMatch, error) {
    // Process without copying entire file
}
```

#### Acceptance Criteria
- [ ] 40% reduction in memory allocations
- [ ] Large files processed efficiently
- [ ] Pattern compilation cached
- [ ] Buffer pools implemented
- [ ] Unicode accuracy maintained

### Task 3.3: Optimize CLI Interface
**Priority:** Medium | **Effort:** 1 week | **Assignee:** Mid-level Developer

#### Command Composition
```go
type BaseCommand struct {
    Name        string
    Description string
    Flags       []Flag
    Handler     CommandHandler
}

var IgnoreAllowlistFlag = Flag{
    Name:        "ignore-allowlist", 
    Description: "Ignore configured emoji allowlist",
    Type:        BoolFlag,
    Default:     false,
}
```

#### Acceptance Criteria
- [ ] 50% startup time reduction
- [ ] Flag definitions reused
- [ ] Progress bars for long operations
- [ ] Better error messages
- [ ] Command suggestions work

### Task 3.4: Implement Advanced Error Handling
**Priority:** High | **Effort:** 1 week | **Assignee:** Senior Developer

#### Domain-Specific Errors
```go
type EmojiDetectionError struct {
    File    string
    Line    int
    Column  int
    Message string
    Cause   error
}

func (e EmojiDetectionError) Error() string {
    return fmt.Sprintf("emoji detection failed in %s:%d:%d: %s", 
        e.File, e.Line, e.Column, e.Message)
}
```

#### Acceptance Criteria
- [ ] All errors include context
- [ ] Programmatic error handling
- [ ] Error chains show failure path
- [ ] Transient errors retried
- [ ] User-friendly messages

### Task 3.5: Implement Comprehensive Monitoring
**Priority:** Medium | **Effort:** 1 week | **Assignee:** Mid-level Developer

#### Monitoring Integration
```go
type Metrics struct {
    ProcessingTime time.Duration
    MemoryUsage    int64
    Throughput     float64
}

func (m *Metrics) Export() map[string]interface{} {
    // Export metrics for monitoring systems
}
```

#### Acceptance Criteria
- [ ] Processing metrics collected
- [ ] Health checks implemented
- [ ] OpenTelemetry tracing
- [ ] Metrics exportable
- [ ] <5% monitoring overhead

### Task 3.6: Final Integration Testing
**Priority:** Critical | **Effort:** 1 week | **Assignee:** All Developers

#### Validation Commands
```bash
./bin/antimoji scan --recursive --stats /large/repo/
./bin/antimoji clean --dry-run --recursive .
./bin/antimoji generate --type=ci-lint .
./bin/antimoji setup-lint --mode=zero-tolerance
go test ./... -bench=. -benchmem
```

#### Acceptance Criteria
- [ ] All CLI commands work
- [ ] Performance targets met
- [ ] Memory usage reduced
- [ ] No functionality regressions
- [ ] Production ready

---

## üìä Implementation Timeline

| Week | Stage | Tasks | Deliverables |
|------|-------|-------|--------------|
| 1-2 | 1 | Remove global state | DI container, no globals |
| 3-4 | 1 | Fix error handling | Safe Result type, no panics |
| 5-6 | 1 | Application bootstrap | Clean main.go, DI working |
| 7-9 | 2 | Domain-driven design | Domain layer, rich models |
| 10-11 | 2 | Repository pattern | Data access abstraction |
| 12 | 2 | Use cases & testing | Business logic layer |
| 13-14 | 3 | Performance optimization | Memory & concurrency |
| 15 | 3 | Monitoring & errors | Observability complete |
| 16 | 3 | Integration testing | Production ready |

---

## üéØ Success Metrics

### Performance Targets
- [ ] 30% memory usage reduction for large files
- [ ] 50% CLI startup time improvement  
- [ ] 40% reduction in memory allocations
- [ ] Processing speed maintained or improved
- [ ] <5% monitoring overhead

### Quality Targets
- [ ] Zero global state in application
- [ ] No panics in production code paths
- [ ] 85%+ test coverage maintained
- [ ] All dependencies injected
- [ ] Clean architecture implemented

### Operational Targets
- [ ] All CLI functionality preserved
- [ ] Configuration loading works correctly
- [ ] Error messages provide helpful context
- [ ] Large repositories process successfully
- [ ] Concurrent usage handled correctly

---

## ‚ö†Ô∏è Risk Management

### High-Risk Areas
1. **Clean Architecture Migration** - Complex refactoring with high impact
2. **Performance Regression** - Memory/speed optimizations may introduce bugs
3. **Breaking Changes** - API changes may affect integrations

### Mitigation Strategies
1. **Feature Flags** - Gradual rollout of changes
2. **Comprehensive Testing** - Maintain test coverage throughout
3. **Performance Benchmarking** - Continuous performance monitoring
4. **Rollback Plans** - Ability to revert changes quickly

### Contingency Plans
- If performance degrades >10%, rollback optimization changes
- If tests fail consistently, pause refactoring until fixed
- If complexity increases significantly, simplify approach

---

## üìã Implementation Checklist

### Pre-Refactoring
- [ ] Create feature branch: `refactor/20250909-architecture`
- [ ] Establish performance baseline benchmarks
- [ ] Document current API contracts
- [ ] Set up continuous integration for refactor branch

### During Refactoring
- [ ] Daily standup updates on progress
- [ ] Weekly architecture review sessions
- [ ] Continuous performance monitoring
- [ ] Regular integration testing

### Post-Refactoring
- [ ] Performance comparison with baseline
- [ ] Full integration test suite
- [ ] Documentation updates
- [ ] Team training on new architecture

---

## üìö References

- **Clean Architecture:** Robert C. Martin
- **Domain-Driven Design:** Eric Evans  
- **Dependency Injection Patterns:** Mark Seemann
- **Go Concurrency Patterns:** Go Team
- **Error Handling Best Practices:** Go Community

---

**Document Owner:** Development Team  
**Last Updated:** September 9, 2025  
**Next Review:** Weekly during implementation  
**Approval:** Pending architecture review
